/*
 * Docker Engine API
 * The Engine API is an HTTP API served by Docker Engine. It is the API the Docker client uses to communicate with the Engine, so everything the Docker client can do can be done with the API.  Most of the client's commands map directly to API endpoints (e.g. `docker ps` is `GET /containers/json`). The notable exception is running containers, which consists of several API calls.  # Errors  The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:  ``` {   \"message\": \"page not found\" } ```  # Versioning  The API is usually changed in each release, so API calls are versioned to ensure that clients don't break. To lock to a specific version of the API, you prefix the URL with its version, for example, call `/v1.30/info` to use the v1.30 version of the `/info` endpoint. If the API version specified in the URL is not supported by the daemon, a HTTP `400 Bad Request` error message is returned.  If you omit the version-prefix, the current version of the API (v1.41) is used. For example, calling `/info` is the same as calling `/v1.41/info`. Using the API without a version-prefix is deprecated and will be removed in a future release.  Engine releases in the near future should support this version of the API, so your client will continue to work even if it is talking to a newer Engine.  The API uses an open schema model, which means server may add extra properties to responses. Likewise, the server will ignore any extra query parameters and request body properties. When you write clients, you need to ignore additional properties in responses to ensure they do not break when talking to newer daemons.   # Authentication  Authentication for registries is handled client side. The client has to send authentication details to various endpoints that need to communicate with registries, such as `POST /images/(name)/push`. These are sent as `X-Registry-Auth` header as a [base64url encoded](https://tools.ietf.org/html/rfc4648#section-5) (JSON) string with the following structure:  ``` {   \"username\": \"string\",   \"password\": \"string\",   \"email\": \"string\",   \"serveraddress\": \"string\" } ```  The `serveraddress` is a domain/IP without a protocol. Throughout this structure, double quotes are required.  If you have already got an identity token from the [`/auth` endpoint](#operation/SystemAuth), you can just pass this instead of credentials:  ``` {   \"identitytoken\": \"9cbaf023786cd7...\" } ``` 
 *
 * OpenAPI spec version: 1.41
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 *
 * Swagger Codegen version: 2.4.21
 *
 * Do not edit the class manually.
 *
 */

(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD.
    define(['expect.js', '../../src/index'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS-like environments that support module.exports, like Node.
    factory(require('expect.js'), require('../../src/index'));
  } else {
    // Browser globals (root is window)
    factory(root.expect, root.DockerEngineApi);
  }
}(this, function(expect, DockerEngineApi) {
  'use strict';

  var instance;

  beforeEach(function() {
    instance = new DockerEngineApi.ServiceApi();
  });

  describe('(package)', function() {
    describe('ServiceApi', function() {
      describe('serviceCreate', function() {
        it('should call serviceCreate successfully', function(done) {
          // TODO: uncomment, update parameter values for serviceCreate call and complete the assertions
          /*
          var body = new DockerEngineApi.object();
          var opts = {};
          opts.xRegistryAuth = "xRegistryAuth_example";

          instance.serviceCreate(body, opts, function(error, data, response) {
            if (error) {
              done(error);
              return;
            }
            // TODO: update response assertions
            expect(data).to.be.a(DockerEngineApi.ServiceCreateResponse);
            expect(data.ID).to.be.a('string');
            expect(data.ID).to.be("");
            expect(data.warning).to.be.a('string');
            expect(data.warning).to.be("");

            done();
          });
          */
          // TODO: uncomment and complete method invocation above, then delete this line and the next:
          done();
        });
      });
      describe('serviceDelete', function() {
        it('should call serviceDelete successfully', function(done) {
          // TODO: uncomment, update parameter values for serviceDelete call
          /*
          var id = "id_example";

          instance.serviceDelete(id, function(error, data, response) {
            if (error) {
              done(error);
              return;
            }

            done();
          });
          */
          // TODO: uncomment and complete method invocation above, then delete this line and the next:
          done();
        });
      });
      describe('serviceInspect', function() {
        it('should call serviceInspect successfully', function(done) {
          // TODO: uncomment, update parameter values for serviceInspect call and complete the assertions
          /*
          var id = "id_example";
          var opts = {};
          opts.insertDefaults = false;

          instance.serviceInspect(id, opts, function(error, data, response) {
            if (error) {
              done(error);
              return;
            }
            // TODO: update response assertions
            expect(data).to.be.a(DockerEngineApi.Service);
            expect(data.ID).to.be.a('string');
            expect(data.ID).to.be("");
            expect(data.version).to.be.a(DockerEngineApi.ObjectVersion);
                  expect(data.version.index).to.be.a('number');
              expect(data.version.index).to.be(373531);
            expect(data.createdAt).to.be.a('string');
            expect(data.createdAt).to.be("");
            expect(data.updatedAt).to.be.a('string');
            expect(data.updatedAt).to.be("");
            expect(data.spec).to.be.a(DockerEngineApi.ServiceSpec);
                  expect(data.spec.name).to.be.a('string');
              expect(data.spec.name).to.be("");
              {
                let dataCtr = data.spec.labels;
                expect(dataCtr).to.be.an(Object);
                expect(dataCtr).to.not.be.empty();
                for (let p in dataCtr) {
                  let data = dataCtr[p];
                  expect(data).to.be.a('string');
                  expect(data).to.be("");
                }
              }
              expect(data.spec.taskTemplate).to.be.a(DockerEngineApi.TaskSpec);
                    expect(data.spec.taskTemplate.pluginSpec).to.be.a(DockerEngineApi.TaskSpecPluginSpec);
                      expect(data.spec.taskTemplate.pluginSpec.name).to.be.a('string');
                  expect(data.spec.taskTemplate.pluginSpec.name).to.be("");
                  expect(data.spec.taskTemplate.pluginSpec.remote).to.be.a('string');
                  expect(data.spec.taskTemplate.pluginSpec.remote).to.be("");
                  expect(data.spec.taskTemplate.pluginSpec.disabled).to.be.a('boolean');
                  expect(data.spec.taskTemplate.pluginSpec.disabled).to.be(false);
                  {
                    let dataCtr = data.spec.taskTemplate.pluginSpec.pluginPrivilege;
                    expect(dataCtr).to.be.an(Array);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a(DockerEngineApi.Body);
                      expect(data.name).to.be.a('string');
                      expect(data.name).to.be("");
                      expect(data.description).to.be.a('string');
                      expect(data.description).to.be("");
                      {
                        let dataCtr = data.value;
                        expect(dataCtr).to.be.an(Array);
                        expect(dataCtr).to.not.be.empty();
                        for (let p in dataCtr) {
                          let data = dataCtr[p];
                          expect(data).to.be.a('string');
                          expect(data).to.be("");
                        }
                      }
      
                            }
                  }
                expect(data.spec.taskTemplate.containerSpec).to.be.a(DockerEngineApi.TaskSpecContainerSpec);
                      expect(data.spec.taskTemplate.containerSpec.image).to.be.a('string');
                  expect(data.spec.taskTemplate.containerSpec.image).to.be("");
                  {
                    let dataCtr = data.spec.taskTemplate.containerSpec.labels;
                    expect(dataCtr).to.be.an(Object);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a('string');
                      expect(data).to.be("");
                    }
                  }
                  {
                    let dataCtr = data.spec.taskTemplate.containerSpec.command;
                    expect(dataCtr).to.be.an(Array);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a('string');
                      expect(data).to.be("");
                    }
                  }
                  {
                    let dataCtr = data.spec.taskTemplate.containerSpec.args;
                    expect(dataCtr).to.be.an(Array);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a('string');
                      expect(data).to.be("");
                    }
                  }
                  expect(data.spec.taskTemplate.containerSpec.hostname).to.be.a('string');
                  expect(data.spec.taskTemplate.containerSpec.hostname).to.be("");
                  {
                    let dataCtr = data.spec.taskTemplate.containerSpec.env;
                    expect(dataCtr).to.be.an(Array);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a('string');
                      expect(data).to.be("");
                    }
                  }
                  expect(data.spec.taskTemplate.containerSpec.dir).to.be.a('string');
                  expect(data.spec.taskTemplate.containerSpec.dir).to.be("");
                  expect(data.spec.taskTemplate.containerSpec.user).to.be.a('string');
                  expect(data.spec.taskTemplate.containerSpec.user).to.be("");
                  {
                    let dataCtr = data.spec.taskTemplate.containerSpec.groups;
                    expect(dataCtr).to.be.an(Array);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a('string');
                      expect(data).to.be("");
                    }
                  }
                  expect(data.spec.taskTemplate.containerSpec.privileges).to.be.a(DockerEngineApi.TaskSpecContainerSpecPrivileges);
                        expect(data.spec.taskTemplate.containerSpec.privileges.credentialSpec).to.be.a(DockerEngineApi.TaskSpecContainerSpecPrivilegesCredentialSpec);
                          expect(data.spec.taskTemplate.containerSpec.privileges.credentialSpec.config).to.be.a('string');
                      expect(data.spec.taskTemplate.containerSpec.privileges.credentialSpec.config).to.be("0bt9dmxjvjiqermk6xrop3ekq");
                      expect(data.spec.taskTemplate.containerSpec.privileges.credentialSpec.file).to.be.a('string');
                      expect(data.spec.taskTemplate.containerSpec.privileges.credentialSpec.file).to.be("spec.json");
                      expect(data.spec.taskTemplate.containerSpec.privileges.credentialSpec.registry).to.be.a('string');
                      expect(data.spec.taskTemplate.containerSpec.privileges.credentialSpec.registry).to.be("");
                    expect(data.spec.taskTemplate.containerSpec.privileges.sELinuxContext).to.be.a(DockerEngineApi.TaskSpecContainerSpecPrivilegesSELinuxContext);
                          expect(data.spec.taskTemplate.containerSpec.privileges.sELinuxContext.disable).to.be.a('boolean');
                      expect(data.spec.taskTemplate.containerSpec.privileges.sELinuxContext.disable).to.be(false);
                      expect(data.spec.taskTemplate.containerSpec.privileges.sELinuxContext.user).to.be.a('string');
                      expect(data.spec.taskTemplate.containerSpec.privileges.sELinuxContext.user).to.be("");
                      expect(data.spec.taskTemplate.containerSpec.privileges.sELinuxContext.role).to.be.a('string');
                      expect(data.spec.taskTemplate.containerSpec.privileges.sELinuxContext.role).to.be("");
                      expect(data.spec.taskTemplate.containerSpec.privileges.sELinuxContext.type).to.be.a('string');
                      expect(data.spec.taskTemplate.containerSpec.privileges.sELinuxContext.type).to.be("");
                      expect(data.spec.taskTemplate.containerSpec.privileges.sELinuxContext.level).to.be.a('string');
                      expect(data.spec.taskTemplate.containerSpec.privileges.sELinuxContext.level).to.be("");
                  expect(data.spec.taskTemplate.containerSpec.TTY).to.be.a('boolean');
                  expect(data.spec.taskTemplate.containerSpec.TTY).to.be(false);
                  expect(data.spec.taskTemplate.containerSpec.openStdin).to.be.a('boolean');
                  expect(data.spec.taskTemplate.containerSpec.openStdin).to.be(false);
                  expect(data.spec.taskTemplate.containerSpec.readOnly).to.be.a('boolean');
                  expect(data.spec.taskTemplate.containerSpec.readOnly).to.be(false);
                  {
                    let dataCtr = data.spec.taskTemplate.containerSpec.mounts;
                    expect(dataCtr).to.be.an(Array);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a(DockerEngineApi.Mount);
                      expect(data.target).to.be.a('string');
                      expect(data.target).to.be("");
                      expect(data.source).to.be.a('string');
                      expect(data.source).to.be("");
                      expect(data.type).to.be.a('string');
                      expect(data.type).to.be("bind");
                      expect(data.readOnly).to.be.a('boolean');
                      expect(data.readOnly).to.be(false);
                      expect(data.consistency).to.be.a('string');
                      expect(data.consistency).to.be("");
                      expect(data.bindOptions).to.be.a(DockerEngineApi.MountBindOptions);
                            expect(data.bindOptions.propagation).to.be.a('string');
                        expect(data.bindOptions.propagation).to.be("private");
                        expect(data.bindOptions.nonRecursive).to.be.a('boolean');
                        expect(data.bindOptions.nonRecursive).to.be(false);
                      expect(data.volumeOptions).to.be.a(DockerEngineApi.MountVolumeOptions);
                            expect(data.volumeOptions.noCopy).to.be.a('boolean');
                        expect(data.volumeOptions.noCopy).to.be(false);
                        {
                          let dataCtr = data.volumeOptions.labels;
                          expect(dataCtr).to.be.an(Object);
                          expect(dataCtr).to.not.be.empty();
                          for (let p in dataCtr) {
                            let data = dataCtr[p];
                            expect(data).to.be.a('string');
                            expect(data).to.be("");
                          }
                        }
                        expect(data.volumeOptions.driverConfig).to.be.a(DockerEngineApi.MountVolumeOptionsDriverConfig);
                              expect(data.volumeOptions.driverConfig.name).to.be.a('string');
                          expect(data.volumeOptions.driverConfig.name).to.be("");
                          {
                            let dataCtr = data.volumeOptions.driverConfig.options;
                            expect(dataCtr).to.be.an(Object);
                            expect(dataCtr).to.not.be.empty();
                            for (let p in dataCtr) {
                              let data = dataCtr[p];
                              expect(data).to.be.a('string');
                              expect(data).to.be("");
                            }
                          }
                      expect(data.tmpfsOptions).to.be.a(DockerEngineApi.MountTmpfsOptions);
                            expect(data.tmpfsOptions.sizeBytes).to.be.a('number');
                        expect(data.tmpfsOptions.sizeBytes).to.be("0");
                        expect(data.tmpfsOptions.mode).to.be.a('number');
                        expect(data.tmpfsOptions.mode).to.be(0);
      
                            }
                  }
                  expect(data.spec.taskTemplate.containerSpec.stopSignal).to.be.a('string');
                  expect(data.spec.taskTemplate.containerSpec.stopSignal).to.be("");
                  expect(data.spec.taskTemplate.containerSpec.stopGracePeriod).to.be.a('number');
                  expect(data.spec.taskTemplate.containerSpec.stopGracePeriod).to.be("0");
                  expect(data.spec.taskTemplate.containerSpec.healthCheck).to.be.a(DockerEngineApi.HealthConfig);
                        {
                      let dataCtr = data.spec.taskTemplate.containerSpec.healthCheck.test;
                      expect(dataCtr).to.be.an(Array);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a('string');
                        expect(data).to.be("");
                      }
                    }
                    expect(data.spec.taskTemplate.containerSpec.healthCheck.interval).to.be.a('number');
                    expect(data.spec.taskTemplate.containerSpec.healthCheck.interval).to.be(0);
                    expect(data.spec.taskTemplate.containerSpec.healthCheck.timeout).to.be.a('number');
                    expect(data.spec.taskTemplate.containerSpec.healthCheck.timeout).to.be(0);
                    expect(data.spec.taskTemplate.containerSpec.healthCheck.retries).to.be.a('number');
                    expect(data.spec.taskTemplate.containerSpec.healthCheck.retries).to.be(0);
                    expect(data.spec.taskTemplate.containerSpec.healthCheck.startPeriod).to.be.a('number');
                    expect(data.spec.taskTemplate.containerSpec.healthCheck.startPeriod).to.be(0);
                  {
                    let dataCtr = data.spec.taskTemplate.containerSpec.hosts;
                    expect(dataCtr).to.be.an(Array);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a('string');
                      expect(data).to.be("");
                    }
                  }
                  expect(data.spec.taskTemplate.containerSpec.dNSConfig).to.be.a(DockerEngineApi.TaskSpecContainerSpecDNSConfig);
                        {
                      let dataCtr = data.spec.taskTemplate.containerSpec.dNSConfig.nameservers;
                      expect(dataCtr).to.be.an(Array);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a('string');
                        expect(data).to.be("");
                      }
                    }
                    {
                      let dataCtr = data.spec.taskTemplate.containerSpec.dNSConfig.search;
                      expect(dataCtr).to.be.an(Array);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a('string');
                        expect(data).to.be("");
                      }
                    }
                    {
                      let dataCtr = data.spec.taskTemplate.containerSpec.dNSConfig.options;
                      expect(dataCtr).to.be.an(Array);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a('string');
                        expect(data).to.be("");
                      }
                    }
                  {
                    let dataCtr = data.spec.taskTemplate.containerSpec.secrets;
                    expect(dataCtr).to.be.an(Array);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a(DockerEngineApi.TaskSpecContainerSpecSecrets);
                      expect(data.file).to.be.a(DockerEngineApi.TaskSpecContainerSpecFile);
                            expect(data.file.name).to.be.a('string');
                        expect(data.file.name).to.be("");
                        expect(data.file.UID).to.be.a('string');
                        expect(data.file.UID).to.be("");
                        expect(data.file.GID).to.be.a('string');
                        expect(data.file.GID).to.be("");
                        expect(data.file.mode).to.be.a('number');
                        expect(data.file.mode).to.be(0);
                      expect(data.secretID).to.be.a('string');
                      expect(data.secretID).to.be("");
                      expect(data.secretName).to.be.a('string');
                      expect(data.secretName).to.be("");
      
                            }
                  }
                  {
                    let dataCtr = data.spec.taskTemplate.containerSpec.configs;
                    expect(dataCtr).to.be.an(Array);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a(DockerEngineApi.TaskSpecContainerSpecConfigs);
                      expect(data.file).to.be.a(DockerEngineApi.TaskSpecContainerSpecFile1);
                            expect(data.file.name).to.be.a('string');
                        expect(data.file.name).to.be("");
                        expect(data.file.UID).to.be.a('string');
                        expect(data.file.UID).to.be("");
                        expect(data.file.GID).to.be.a('string');
                        expect(data.file.GID).to.be("");
                        expect(data.file.mode).to.be.a('number');
                        expect(data.file.mode).to.be(0);
                      expect(data.runtime).to.be.a(Object);
                      expect(data.runtime).to.be();
                      expect(data.configID).to.be.a('string');
                      expect(data.configID).to.be("");
                      expect(data.configName).to.be.a('string');
                      expect(data.configName).to.be("");
      
                            }
                  }
                  expect(data.spec.taskTemplate.containerSpec.isolation).to.be.a('string');
                  expect(data.spec.taskTemplate.containerSpec.isolation).to.be("default");
                  expect(data.spec.taskTemplate.containerSpec.init).to.be.a('boolean');
                  expect(data.spec.taskTemplate.containerSpec.init).to.be(false);
                  {
                    let dataCtr = data.spec.taskTemplate.containerSpec.sysctls;
                    expect(dataCtr).to.be.an(Object);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a('string');
                      expect(data).to.be("");
                    }
                  }
                  {
                    let dataCtr = data.spec.taskTemplate.containerSpec.capabilityAdd;
                    expect(dataCtr).to.be.an(Array);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a('string');
                      expect(data).to.be("");
                    }
                  }
                  {
                    let dataCtr = data.spec.taskTemplate.containerSpec.capabilityDrop;
                    expect(dataCtr).to.be.an(Array);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a('string');
                      expect(data).to.be("");
                    }
                  }
                  {
                    let dataCtr = data.spec.taskTemplate.containerSpec.ulimits;
                    expect(dataCtr).to.be.an(Array);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a(DockerEngineApi.ResourcesUlimits);
                      expect(data.name).to.be.a('string');
                      expect(data.name).to.be("");
                      expect(data.soft).to.be.a('number');
                      expect(data.soft).to.be(0);
                      expect(data.hard).to.be.a('number');
                      expect(data.hard).to.be(0);
      
                            }
                  }
                expect(data.spec.taskTemplate.networkAttachmentSpec).to.be.a(DockerEngineApi.TaskSpecNetworkAttachmentSpec);
                      expect(data.spec.taskTemplate.networkAttachmentSpec.containerID).to.be.a('string');
                  expect(data.spec.taskTemplate.networkAttachmentSpec.containerID).to.be("");
                expect(data.spec.taskTemplate.resources).to.be.a(DockerEngineApi.TaskSpecResources);
                      expect(data.spec.taskTemplate.resources.limits).to.be.a(DockerEngineApi.Limit);
                        expect(data.spec.taskTemplate.resources.limits.nanoCPUs).to.be.a('number');
                    expect(data.spec.taskTemplate.resources.limits.nanoCPUs).to.be(4000000000);
                    expect(data.spec.taskTemplate.resources.limits.memoryBytes).to.be.a('number');
                    expect(data.spec.taskTemplate.resources.limits.memoryBytes).to.be(8272408576);
                    expect(data.spec.taskTemplate.resources.limits.pids).to.be.a('number');
                    expect(data.spec.taskTemplate.resources.limits.pids).to.be(100);
                  expect(data.spec.taskTemplate.resources.reservation).to.be.a(DockerEngineApi.ResourceObject);
                        expect(data.spec.taskTemplate.resources.reservation.nanoCPUs).to.be.a('number');
                    expect(data.spec.taskTemplate.resources.reservation.nanoCPUs).to.be(4000000000);
                    expect(data.spec.taskTemplate.resources.reservation.memoryBytes).to.be.a('number');
                    expect(data.spec.taskTemplate.resources.reservation.memoryBytes).to.be(8272408576);
                    expect(data.spec.taskTemplate.resources.reservation.genericResources).to.be.a(DockerEngineApi.GenericResources);
            
                expect(data.spec.taskTemplate.restartPolicy).to.be.a(DockerEngineApi.TaskSpecRestartPolicy);
                      expect(data.spec.taskTemplate.restartPolicy.condition).to.be.a('string');
                  expect(data.spec.taskTemplate.restartPolicy.condition).to.be("none");
                  expect(data.spec.taskTemplate.restartPolicy.delay).to.be.a('number');
                  expect(data.spec.taskTemplate.restartPolicy.delay).to.be("0");
                  expect(data.spec.taskTemplate.restartPolicy.maxAttempts).to.be.a('number');
                  expect(data.spec.taskTemplate.restartPolicy.maxAttempts).to.be("0");
                  expect(data.spec.taskTemplate.restartPolicy.window).to.be.a('number');
                  expect(data.spec.taskTemplate.restartPolicy.window).to.be("0");
                expect(data.spec.taskTemplate.placement).to.be.a(DockerEngineApi.TaskSpecPlacement);
                      {
                    let dataCtr = data.spec.taskTemplate.placement.constraints;
                    expect(dataCtr).to.be.an(Array);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a('string');
                      expect(data).to.be("");
                    }
                  }
                  {
                    let dataCtr = data.spec.taskTemplate.placement.preferences;
                    expect(dataCtr).to.be.an(Array);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a(DockerEngineApi.TaskSpecPlacementPreferences);
                      expect(data.spread).to.be.a(DockerEngineApi.TaskSpecPlacementSpread);
                            expect(data.spread.spreadDescriptor).to.be.a('string');
                        expect(data.spread.spreadDescriptor).to.be("");
      
                            }
                  }
                  expect(data.spec.taskTemplate.placement.maxReplicas).to.be.a('number');
                  expect(data.spec.taskTemplate.placement.maxReplicas).to.be("0");
                  {
                    let dataCtr = data.spec.taskTemplate.placement.platforms;
                    expect(dataCtr).to.be.an(Array);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a(DockerEngineApi.Platform);
                      expect(data.architecture).to.be.a('string');
                      expect(data.architecture).to.be("x86_64");
                      expect(data.OS).to.be.a('string');
                      expect(data.OS).to.be("linux");
      
                            }
                  }
                expect(data.spec.taskTemplate.forceUpdate).to.be.a('number');
                expect(data.spec.taskTemplate.forceUpdate).to.be(0);
                expect(data.spec.taskTemplate.runtime).to.be.a('string');
                expect(data.spec.taskTemplate.runtime).to.be("");
                {
                  let dataCtr = data.spec.taskTemplate.networks;
                  expect(dataCtr).to.be.an(Array);
                  expect(dataCtr).to.not.be.empty();
                  for (let p in dataCtr) {
                    let data = dataCtr[p];
                    expect(data).to.be.a(DockerEngineApi.NetworkAttachmentConfig);
                    expect(data.target).to.be.a('string');
                    expect(data.target).to.be("");
                    {
                      let dataCtr = data.aliases;
                      expect(dataCtr).to.be.an(Array);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a('string');
                        expect(data).to.be("");
                      }
                    }
                    {
                      let dataCtr = data.driverOpts;
                      expect(dataCtr).to.be.an(Object);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a('string');
                        expect(data).to.be("");
                      }
                    }
    
                          }
                }
                expect(data.spec.taskTemplate.logDriver).to.be.a(DockerEngineApi.TaskSpecLogDriver);
                      expect(data.spec.taskTemplate.logDriver.name).to.be.a('string');
                  expect(data.spec.taskTemplate.logDriver.name).to.be("");
                  {
                    let dataCtr = data.spec.taskTemplate.logDriver.options;
                    expect(dataCtr).to.be.an(Object);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a('string');
                      expect(data).to.be("");
                    }
                  }
              expect(data.spec.mode).to.be.a(DockerEngineApi.ServiceSpecMode);
                    expect(data.spec.mode.replicated).to.be.a(DockerEngineApi.ServiceSpecModeReplicated);
                      expect(data.spec.mode.replicated.replicas).to.be.a('number');
                  expect(data.spec.mode.replicated.replicas).to.be("0");
                expect(data.spec.mode.global).to.be.a(Object);
                expect(data.spec.mode.global).to.be();
                expect(data.spec.mode.replicatedJob).to.be.a(DockerEngineApi.ServiceSpecModeReplicatedJob);
                      expect(data.spec.mode.replicatedJob.maxConcurrent).to.be.a('number');
                  expect(data.spec.mode.replicatedJob.maxConcurrent).to.be("0");
                  expect(data.spec.mode.replicatedJob.totalCompletions).to.be.a('number');
                  expect(data.spec.mode.replicatedJob.totalCompletions).to.be("0");
                expect(data.spec.mode.globalJob).to.be.a(Object);
                expect(data.spec.mode.globalJob).to.be();
              expect(data.spec.updateConfig).to.be.a(DockerEngineApi.ServiceSpecUpdateConfig);
                    expect(data.spec.updateConfig.parallelism).to.be.a('number');
                expect(data.spec.updateConfig.parallelism).to.be("0");
                expect(data.spec.updateConfig.delay).to.be.a('number');
                expect(data.spec.updateConfig.delay).to.be("0");
                expect(data.spec.updateConfig.failureAction).to.be.a('string');
                expect(data.spec.updateConfig.failureAction).to.be("continue");
                expect(data.spec.updateConfig.monitor).to.be.a('number');
                expect(data.spec.updateConfig.monitor).to.be("0");
                expect(data.spec.updateConfig.maxFailureRatio).to.be.a('number');
                expect(data.spec.updateConfig.maxFailureRatio).to.be();
                expect(data.spec.updateConfig.order).to.be.a('string');
                expect(data.spec.updateConfig.order).to.be("stop-first");
              expect(data.spec.rollbackConfig).to.be.a(DockerEngineApi.ServiceSpecRollbackConfig);
                    expect(data.spec.rollbackConfig.parallelism).to.be.a('number');
                expect(data.spec.rollbackConfig.parallelism).to.be("0");
                expect(data.spec.rollbackConfig.delay).to.be.a('number');
                expect(data.spec.rollbackConfig.delay).to.be("0");
                expect(data.spec.rollbackConfig.failureAction).to.be.a('string');
                expect(data.spec.rollbackConfig.failureAction).to.be("continue");
                expect(data.spec.rollbackConfig.monitor).to.be.a('number');
                expect(data.spec.rollbackConfig.monitor).to.be("0");
                expect(data.spec.rollbackConfig.maxFailureRatio).to.be.a('number');
                expect(data.spec.rollbackConfig.maxFailureRatio).to.be();
                expect(data.spec.rollbackConfig.order).to.be.a('string');
                expect(data.spec.rollbackConfig.order).to.be("stop-first");
              {
                let dataCtr = data.spec.networks;
                expect(dataCtr).to.be.an(Array);
                expect(dataCtr).to.not.be.empty();
                for (let p in dataCtr) {
                  let data = dataCtr[p];
                  expect(data).to.be.a(DockerEngineApi.NetworkAttachmentConfig);
                  expect(data.target).to.be.a('string');
                  expect(data.target).to.be("");
                  {
                    let dataCtr = data.aliases;
                    expect(dataCtr).to.be.an(Array);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a('string');
                      expect(data).to.be("");
                    }
                  }
                  {
                    let dataCtr = data.driverOpts;
                    expect(dataCtr).to.be.an(Object);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a('string');
                      expect(data).to.be("");
                    }
                  }
  
                        }
              }
              expect(data.spec.endpointSpec).to.be.a(DockerEngineApi.EndpointSpec);
                    expect(data.spec.endpointSpec.mode).to.be.a('string');
                expect(data.spec.endpointSpec.mode).to.be("vip");
                {
                  let dataCtr = data.spec.endpointSpec.ports;
                  expect(dataCtr).to.be.an(Array);
                  expect(dataCtr).to.not.be.empty();
                  for (let p in dataCtr) {
                    let data = dataCtr[p];
                    expect(data).to.be.a(DockerEngineApi.EndpointPortConfig);
                    expect(data.name).to.be.a('string');
                    expect(data.name).to.be("");
                    expect(data.protocol).to.be.a('string');
                    expect(data.protocol).to.be("tcp");
                    expect(data.targetPort).to.be.a('number');
                    expect(data.targetPort).to.be(0);
                    expect(data.publishedPort).to.be.a('number');
                    expect(data.publishedPort).to.be(0);
                    expect(data.publishMode).to.be.a('string');
                    expect(data.publishMode).to.be("ingress");
    
                          }
                }
            expect(data.endpoint).to.be.a(DockerEngineApi.ServiceEndpoint);
                  expect(data.endpoint.spec).to.be.a(DockerEngineApi.EndpointSpec);
                    expect(data.endpoint.spec.mode).to.be.a('string');
                expect(data.endpoint.spec.mode).to.be("vip");
                {
                  let dataCtr = data.endpoint.spec.ports;
                  expect(dataCtr).to.be.an(Array);
                  expect(dataCtr).to.not.be.empty();
                  for (let p in dataCtr) {
                    let data = dataCtr[p];
                    expect(data).to.be.a(DockerEngineApi.EndpointPortConfig);
                    expect(data.name).to.be.a('string');
                    expect(data.name).to.be("");
                    expect(data.protocol).to.be.a('string');
                    expect(data.protocol).to.be("tcp");
                    expect(data.targetPort).to.be.a('number');
                    expect(data.targetPort).to.be(0);
                    expect(data.publishedPort).to.be.a('number');
                    expect(data.publishedPort).to.be(0);
                    expect(data.publishMode).to.be.a('string');
                    expect(data.publishMode).to.be("ingress");
    
                          }
                }
              {
                let dataCtr = data.endpoint.ports;
                expect(dataCtr).to.be.an(Array);
                expect(dataCtr).to.not.be.empty();
                for (let p in dataCtr) {
                  let data = dataCtr[p];
                  expect(data).to.be.a(DockerEngineApi.EndpointPortConfig);
                  expect(data.name).to.be.a('string');
                  expect(data.name).to.be("");
                  expect(data.protocol).to.be.a('string');
                  expect(data.protocol).to.be("tcp");
                  expect(data.targetPort).to.be.a('number');
                  expect(data.targetPort).to.be(0);
                  expect(data.publishedPort).to.be.a('number');
                  expect(data.publishedPort).to.be(0);
                  expect(data.publishMode).to.be.a('string');
                  expect(data.publishMode).to.be("ingress");
  
                        }
              }
              {
                let dataCtr = data.endpoint.virtualIPs;
                expect(dataCtr).to.be.an(Array);
                expect(dataCtr).to.not.be.empty();
                for (let p in dataCtr) {
                  let data = dataCtr[p];
                  expect(data).to.be.a(DockerEngineApi.ServiceEndpointVirtualIPs);
                  expect(data.networkID).to.be.a('string');
                  expect(data.networkID).to.be("");
                  expect(data.addr).to.be.a('string');
                  expect(data.addr).to.be("");
  
                        }
              }
            expect(data.updateStatus).to.be.a(DockerEngineApi.ServiceUpdateStatus);
                  expect(data.updateStatus.state).to.be.a('string');
              expect(data.updateStatus.state).to.be("updating");
              expect(data.updateStatus.startedAt).to.be.a('string');
              expect(data.updateStatus.startedAt).to.be("");
              expect(data.updateStatus.completedAt).to.be.a('string');
              expect(data.updateStatus.completedAt).to.be("");
              expect(data.updateStatus.message).to.be.a('string');
              expect(data.updateStatus.message).to.be("");
            expect(data.serviceStatus).to.be.a(DockerEngineApi.ServiceServiceStatus);
                  expect(data.serviceStatus.runningTasks).to.be.a('number');
              expect(data.serviceStatus.runningTasks).to.be(7);
              expect(data.serviceStatus.desiredTasks).to.be.a('number');
              expect(data.serviceStatus.desiredTasks).to.be(10);
              expect(data.serviceStatus.completedTasks).to.be.a('number');
              expect(data.serviceStatus.completedTasks).to.be(0);
            expect(data.jobStatus).to.be.a(DockerEngineApi.ServiceJobStatus);
                  expect(data.jobStatus.jobIteration).to.be.a(DockerEngineApi.ObjectVersion);
                    expect(data.jobStatus.jobIteration.index).to.be.a('number');
                expect(data.jobStatus.jobIteration.index).to.be(373531);
              expect(data.jobStatus.lastExecution).to.be.a('string');
              expect(data.jobStatus.lastExecution).to.be("");

            done();
          });
          */
          // TODO: uncomment and complete method invocation above, then delete this line and the next:
          done();
        });
      });
      describe('serviceList', function() {
        it('should call serviceList successfully', function(done) {
          // TODO: uncomment, update parameter values for serviceList call and complete the assertions
          /*
          var opts = {};
          opts.filters = "filters_example";
          opts.status = true;

          instance.serviceList(opts, function(error, data, response) {
            if (error) {
              done(error);
              return;
            }
            // TODO: update response assertions
            let dataCtr = data;
            expect(dataCtr).to.be.an(Array);
            expect(dataCtr).to.not.be.empty();
            for (let p in dataCtr) {
              let data = dataCtr[p];
              expect(data).to.be.a(DockerEngineApi.Service);
              expect(data.ID).to.be.a('string');
              expect(data.ID).to.be("");
              expect(data.version).to.be.a(DockerEngineApi.ObjectVersion);
                    expect(data.version.index).to.be.a('number');
                expect(data.version.index).to.be(373531);
              expect(data.createdAt).to.be.a('string');
              expect(data.createdAt).to.be("");
              expect(data.updatedAt).to.be.a('string');
              expect(data.updatedAt).to.be("");
              expect(data.spec).to.be.a(DockerEngineApi.ServiceSpec);
                    expect(data.spec.name).to.be.a('string');
                expect(data.spec.name).to.be("");
                {
                  let dataCtr = data.spec.labels;
                  expect(dataCtr).to.be.an(Object);
                  expect(dataCtr).to.not.be.empty();
                  for (let p in dataCtr) {
                    let data = dataCtr[p];
                    expect(data).to.be.a('string');
                    expect(data).to.be("");
                  }
                }
                expect(data.spec.taskTemplate).to.be.a(DockerEngineApi.TaskSpec);
                      expect(data.spec.taskTemplate.pluginSpec).to.be.a(DockerEngineApi.TaskSpecPluginSpec);
                        expect(data.spec.taskTemplate.pluginSpec.name).to.be.a('string');
                    expect(data.spec.taskTemplate.pluginSpec.name).to.be("");
                    expect(data.spec.taskTemplate.pluginSpec.remote).to.be.a('string');
                    expect(data.spec.taskTemplate.pluginSpec.remote).to.be("");
                    expect(data.spec.taskTemplate.pluginSpec.disabled).to.be.a('boolean');
                    expect(data.spec.taskTemplate.pluginSpec.disabled).to.be(false);
                    {
                      let dataCtr = data.spec.taskTemplate.pluginSpec.pluginPrivilege;
                      expect(dataCtr).to.be.an(Array);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a(DockerEngineApi.Body);
                        expect(data.name).to.be.a('string');
                        expect(data.name).to.be("");
                        expect(data.description).to.be.a('string');
                        expect(data.description).to.be("");
                        {
                          let dataCtr = data.value;
                          expect(dataCtr).to.be.an(Array);
                          expect(dataCtr).to.not.be.empty();
                          for (let p in dataCtr) {
                            let data = dataCtr[p];
                            expect(data).to.be.a('string');
                            expect(data).to.be("");
                          }
                        }
        
                              }
                    }
                  expect(data.spec.taskTemplate.containerSpec).to.be.a(DockerEngineApi.TaskSpecContainerSpec);
                        expect(data.spec.taskTemplate.containerSpec.image).to.be.a('string');
                    expect(data.spec.taskTemplate.containerSpec.image).to.be("");
                    {
                      let dataCtr = data.spec.taskTemplate.containerSpec.labels;
                      expect(dataCtr).to.be.an(Object);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a('string');
                        expect(data).to.be("");
                      }
                    }
                    {
                      let dataCtr = data.spec.taskTemplate.containerSpec.command;
                      expect(dataCtr).to.be.an(Array);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a('string');
                        expect(data).to.be("");
                      }
                    }
                    {
                      let dataCtr = data.spec.taskTemplate.containerSpec.args;
                      expect(dataCtr).to.be.an(Array);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a('string');
                        expect(data).to.be("");
                      }
                    }
                    expect(data.spec.taskTemplate.containerSpec.hostname).to.be.a('string');
                    expect(data.spec.taskTemplate.containerSpec.hostname).to.be("");
                    {
                      let dataCtr = data.spec.taskTemplate.containerSpec.env;
                      expect(dataCtr).to.be.an(Array);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a('string');
                        expect(data).to.be("");
                      }
                    }
                    expect(data.spec.taskTemplate.containerSpec.dir).to.be.a('string');
                    expect(data.spec.taskTemplate.containerSpec.dir).to.be("");
                    expect(data.spec.taskTemplate.containerSpec.user).to.be.a('string');
                    expect(data.spec.taskTemplate.containerSpec.user).to.be("");
                    {
                      let dataCtr = data.spec.taskTemplate.containerSpec.groups;
                      expect(dataCtr).to.be.an(Array);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a('string');
                        expect(data).to.be("");
                      }
                    }
                    expect(data.spec.taskTemplate.containerSpec.privileges).to.be.a(DockerEngineApi.TaskSpecContainerSpecPrivileges);
                          expect(data.spec.taskTemplate.containerSpec.privileges.credentialSpec).to.be.a(DockerEngineApi.TaskSpecContainerSpecPrivilegesCredentialSpec);
                            expect(data.spec.taskTemplate.containerSpec.privileges.credentialSpec.config).to.be.a('string');
                        expect(data.spec.taskTemplate.containerSpec.privileges.credentialSpec.config).to.be("0bt9dmxjvjiqermk6xrop3ekq");
                        expect(data.spec.taskTemplate.containerSpec.privileges.credentialSpec.file).to.be.a('string');
                        expect(data.spec.taskTemplate.containerSpec.privileges.credentialSpec.file).to.be("spec.json");
                        expect(data.spec.taskTemplate.containerSpec.privileges.credentialSpec.registry).to.be.a('string');
                        expect(data.spec.taskTemplate.containerSpec.privileges.credentialSpec.registry).to.be("");
                      expect(data.spec.taskTemplate.containerSpec.privileges.sELinuxContext).to.be.a(DockerEngineApi.TaskSpecContainerSpecPrivilegesSELinuxContext);
                            expect(data.spec.taskTemplate.containerSpec.privileges.sELinuxContext.disable).to.be.a('boolean');
                        expect(data.spec.taskTemplate.containerSpec.privileges.sELinuxContext.disable).to.be(false);
                        expect(data.spec.taskTemplate.containerSpec.privileges.sELinuxContext.user).to.be.a('string');
                        expect(data.spec.taskTemplate.containerSpec.privileges.sELinuxContext.user).to.be("");
                        expect(data.spec.taskTemplate.containerSpec.privileges.sELinuxContext.role).to.be.a('string');
                        expect(data.spec.taskTemplate.containerSpec.privileges.sELinuxContext.role).to.be("");
                        expect(data.spec.taskTemplate.containerSpec.privileges.sELinuxContext.type).to.be.a('string');
                        expect(data.spec.taskTemplate.containerSpec.privileges.sELinuxContext.type).to.be("");
                        expect(data.spec.taskTemplate.containerSpec.privileges.sELinuxContext.level).to.be.a('string');
                        expect(data.spec.taskTemplate.containerSpec.privileges.sELinuxContext.level).to.be("");
                    expect(data.spec.taskTemplate.containerSpec.TTY).to.be.a('boolean');
                    expect(data.spec.taskTemplate.containerSpec.TTY).to.be(false);
                    expect(data.spec.taskTemplate.containerSpec.openStdin).to.be.a('boolean');
                    expect(data.spec.taskTemplate.containerSpec.openStdin).to.be(false);
                    expect(data.spec.taskTemplate.containerSpec.readOnly).to.be.a('boolean');
                    expect(data.spec.taskTemplate.containerSpec.readOnly).to.be(false);
                    {
                      let dataCtr = data.spec.taskTemplate.containerSpec.mounts;
                      expect(dataCtr).to.be.an(Array);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a(DockerEngineApi.Mount);
                        expect(data.target).to.be.a('string');
                        expect(data.target).to.be("");
                        expect(data.source).to.be.a('string');
                        expect(data.source).to.be("");
                        expect(data.type).to.be.a('string');
                        expect(data.type).to.be("bind");
                        expect(data.readOnly).to.be.a('boolean');
                        expect(data.readOnly).to.be(false);
                        expect(data.consistency).to.be.a('string');
                        expect(data.consistency).to.be("");
                        expect(data.bindOptions).to.be.a(DockerEngineApi.MountBindOptions);
                              expect(data.bindOptions.propagation).to.be.a('string');
                          expect(data.bindOptions.propagation).to.be("private");
                          expect(data.bindOptions.nonRecursive).to.be.a('boolean');
                          expect(data.bindOptions.nonRecursive).to.be(false);
                        expect(data.volumeOptions).to.be.a(DockerEngineApi.MountVolumeOptions);
                              expect(data.volumeOptions.noCopy).to.be.a('boolean');
                          expect(data.volumeOptions.noCopy).to.be(false);
                          {
                            let dataCtr = data.volumeOptions.labels;
                            expect(dataCtr).to.be.an(Object);
                            expect(dataCtr).to.not.be.empty();
                            for (let p in dataCtr) {
                              let data = dataCtr[p];
                              expect(data).to.be.a('string');
                              expect(data).to.be("");
                            }
                          }
                          expect(data.volumeOptions.driverConfig).to.be.a(DockerEngineApi.MountVolumeOptionsDriverConfig);
                                expect(data.volumeOptions.driverConfig.name).to.be.a('string');
                            expect(data.volumeOptions.driverConfig.name).to.be("");
                            {
                              let dataCtr = data.volumeOptions.driverConfig.options;
                              expect(dataCtr).to.be.an(Object);
                              expect(dataCtr).to.not.be.empty();
                              for (let p in dataCtr) {
                                let data = dataCtr[p];
                                expect(data).to.be.a('string');
                                expect(data).to.be("");
                              }
                            }
                        expect(data.tmpfsOptions).to.be.a(DockerEngineApi.MountTmpfsOptions);
                              expect(data.tmpfsOptions.sizeBytes).to.be.a('number');
                          expect(data.tmpfsOptions.sizeBytes).to.be("0");
                          expect(data.tmpfsOptions.mode).to.be.a('number');
                          expect(data.tmpfsOptions.mode).to.be(0);
        
                              }
                    }
                    expect(data.spec.taskTemplate.containerSpec.stopSignal).to.be.a('string');
                    expect(data.spec.taskTemplate.containerSpec.stopSignal).to.be("");
                    expect(data.spec.taskTemplate.containerSpec.stopGracePeriod).to.be.a('number');
                    expect(data.spec.taskTemplate.containerSpec.stopGracePeriod).to.be("0");
                    expect(data.spec.taskTemplate.containerSpec.healthCheck).to.be.a(DockerEngineApi.HealthConfig);
                          {
                        let dataCtr = data.spec.taskTemplate.containerSpec.healthCheck.test;
                        expect(dataCtr).to.be.an(Array);
                        expect(dataCtr).to.not.be.empty();
                        for (let p in dataCtr) {
                          let data = dataCtr[p];
                          expect(data).to.be.a('string');
                          expect(data).to.be("");
                        }
                      }
                      expect(data.spec.taskTemplate.containerSpec.healthCheck.interval).to.be.a('number');
                      expect(data.spec.taskTemplate.containerSpec.healthCheck.interval).to.be(0);
                      expect(data.spec.taskTemplate.containerSpec.healthCheck.timeout).to.be.a('number');
                      expect(data.spec.taskTemplate.containerSpec.healthCheck.timeout).to.be(0);
                      expect(data.spec.taskTemplate.containerSpec.healthCheck.retries).to.be.a('number');
                      expect(data.spec.taskTemplate.containerSpec.healthCheck.retries).to.be(0);
                      expect(data.spec.taskTemplate.containerSpec.healthCheck.startPeriod).to.be.a('number');
                      expect(data.spec.taskTemplate.containerSpec.healthCheck.startPeriod).to.be(0);
                    {
                      let dataCtr = data.spec.taskTemplate.containerSpec.hosts;
                      expect(dataCtr).to.be.an(Array);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a('string');
                        expect(data).to.be("");
                      }
                    }
                    expect(data.spec.taskTemplate.containerSpec.dNSConfig).to.be.a(DockerEngineApi.TaskSpecContainerSpecDNSConfig);
                          {
                        let dataCtr = data.spec.taskTemplate.containerSpec.dNSConfig.nameservers;
                        expect(dataCtr).to.be.an(Array);
                        expect(dataCtr).to.not.be.empty();
                        for (let p in dataCtr) {
                          let data = dataCtr[p];
                          expect(data).to.be.a('string');
                          expect(data).to.be("");
                        }
                      }
                      {
                        let dataCtr = data.spec.taskTemplate.containerSpec.dNSConfig.search;
                        expect(dataCtr).to.be.an(Array);
                        expect(dataCtr).to.not.be.empty();
                        for (let p in dataCtr) {
                          let data = dataCtr[p];
                          expect(data).to.be.a('string');
                          expect(data).to.be("");
                        }
                      }
                      {
                        let dataCtr = data.spec.taskTemplate.containerSpec.dNSConfig.options;
                        expect(dataCtr).to.be.an(Array);
                        expect(dataCtr).to.not.be.empty();
                        for (let p in dataCtr) {
                          let data = dataCtr[p];
                          expect(data).to.be.a('string');
                          expect(data).to.be("");
                        }
                      }
                    {
                      let dataCtr = data.spec.taskTemplate.containerSpec.secrets;
                      expect(dataCtr).to.be.an(Array);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a(DockerEngineApi.TaskSpecContainerSpecSecrets);
                        expect(data.file).to.be.a(DockerEngineApi.TaskSpecContainerSpecFile);
                              expect(data.file.name).to.be.a('string');
                          expect(data.file.name).to.be("");
                          expect(data.file.UID).to.be.a('string');
                          expect(data.file.UID).to.be("");
                          expect(data.file.GID).to.be.a('string');
                          expect(data.file.GID).to.be("");
                          expect(data.file.mode).to.be.a('number');
                          expect(data.file.mode).to.be(0);
                        expect(data.secretID).to.be.a('string');
                        expect(data.secretID).to.be("");
                        expect(data.secretName).to.be.a('string');
                        expect(data.secretName).to.be("");
        
                              }
                    }
                    {
                      let dataCtr = data.spec.taskTemplate.containerSpec.configs;
                      expect(dataCtr).to.be.an(Array);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a(DockerEngineApi.TaskSpecContainerSpecConfigs);
                        expect(data.file).to.be.a(DockerEngineApi.TaskSpecContainerSpecFile1);
                              expect(data.file.name).to.be.a('string');
                          expect(data.file.name).to.be("");
                          expect(data.file.UID).to.be.a('string');
                          expect(data.file.UID).to.be("");
                          expect(data.file.GID).to.be.a('string');
                          expect(data.file.GID).to.be("");
                          expect(data.file.mode).to.be.a('number');
                          expect(data.file.mode).to.be(0);
                        expect(data.runtime).to.be.a(Object);
                        expect(data.runtime).to.be();
                        expect(data.configID).to.be.a('string');
                        expect(data.configID).to.be("");
                        expect(data.configName).to.be.a('string');
                        expect(data.configName).to.be("");
        
                              }
                    }
                    expect(data.spec.taskTemplate.containerSpec.isolation).to.be.a('string');
                    expect(data.spec.taskTemplate.containerSpec.isolation).to.be("default");
                    expect(data.spec.taskTemplate.containerSpec.init).to.be.a('boolean');
                    expect(data.spec.taskTemplate.containerSpec.init).to.be(false);
                    {
                      let dataCtr = data.spec.taskTemplate.containerSpec.sysctls;
                      expect(dataCtr).to.be.an(Object);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a('string');
                        expect(data).to.be("");
                      }
                    }
                    {
                      let dataCtr = data.spec.taskTemplate.containerSpec.capabilityAdd;
                      expect(dataCtr).to.be.an(Array);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a('string');
                        expect(data).to.be("");
                      }
                    }
                    {
                      let dataCtr = data.spec.taskTemplate.containerSpec.capabilityDrop;
                      expect(dataCtr).to.be.an(Array);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a('string');
                        expect(data).to.be("");
                      }
                    }
                    {
                      let dataCtr = data.spec.taskTemplate.containerSpec.ulimits;
                      expect(dataCtr).to.be.an(Array);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a(DockerEngineApi.ResourcesUlimits);
                        expect(data.name).to.be.a('string');
                        expect(data.name).to.be("");
                        expect(data.soft).to.be.a('number');
                        expect(data.soft).to.be(0);
                        expect(data.hard).to.be.a('number');
                        expect(data.hard).to.be(0);
        
                              }
                    }
                  expect(data.spec.taskTemplate.networkAttachmentSpec).to.be.a(DockerEngineApi.TaskSpecNetworkAttachmentSpec);
                        expect(data.spec.taskTemplate.networkAttachmentSpec.containerID).to.be.a('string');
                    expect(data.spec.taskTemplate.networkAttachmentSpec.containerID).to.be("");
                  expect(data.spec.taskTemplate.resources).to.be.a(DockerEngineApi.TaskSpecResources);
                        expect(data.spec.taskTemplate.resources.limits).to.be.a(DockerEngineApi.Limit);
                          expect(data.spec.taskTemplate.resources.limits.nanoCPUs).to.be.a('number');
                      expect(data.spec.taskTemplate.resources.limits.nanoCPUs).to.be(4000000000);
                      expect(data.spec.taskTemplate.resources.limits.memoryBytes).to.be.a('number');
                      expect(data.spec.taskTemplate.resources.limits.memoryBytes).to.be(8272408576);
                      expect(data.spec.taskTemplate.resources.limits.pids).to.be.a('number');
                      expect(data.spec.taskTemplate.resources.limits.pids).to.be(100);
                    expect(data.spec.taskTemplate.resources.reservation).to.be.a(DockerEngineApi.ResourceObject);
                          expect(data.spec.taskTemplate.resources.reservation.nanoCPUs).to.be.a('number');
                      expect(data.spec.taskTemplate.resources.reservation.nanoCPUs).to.be(4000000000);
                      expect(data.spec.taskTemplate.resources.reservation.memoryBytes).to.be.a('number');
                      expect(data.spec.taskTemplate.resources.reservation.memoryBytes).to.be(8272408576);
                      expect(data.spec.taskTemplate.resources.reservation.genericResources).to.be.a(DockerEngineApi.GenericResources);
              
                  expect(data.spec.taskTemplate.restartPolicy).to.be.a(DockerEngineApi.TaskSpecRestartPolicy);
                        expect(data.spec.taskTemplate.restartPolicy.condition).to.be.a('string');
                    expect(data.spec.taskTemplate.restartPolicy.condition).to.be("none");
                    expect(data.spec.taskTemplate.restartPolicy.delay).to.be.a('number');
                    expect(data.spec.taskTemplate.restartPolicy.delay).to.be("0");
                    expect(data.spec.taskTemplate.restartPolicy.maxAttempts).to.be.a('number');
                    expect(data.spec.taskTemplate.restartPolicy.maxAttempts).to.be("0");
                    expect(data.spec.taskTemplate.restartPolicy.window).to.be.a('number');
                    expect(data.spec.taskTemplate.restartPolicy.window).to.be("0");
                  expect(data.spec.taskTemplate.placement).to.be.a(DockerEngineApi.TaskSpecPlacement);
                        {
                      let dataCtr = data.spec.taskTemplate.placement.constraints;
                      expect(dataCtr).to.be.an(Array);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a('string');
                        expect(data).to.be("");
                      }
                    }
                    {
                      let dataCtr = data.spec.taskTemplate.placement.preferences;
                      expect(dataCtr).to.be.an(Array);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a(DockerEngineApi.TaskSpecPlacementPreferences);
                        expect(data.spread).to.be.a(DockerEngineApi.TaskSpecPlacementSpread);
                              expect(data.spread.spreadDescriptor).to.be.a('string');
                          expect(data.spread.spreadDescriptor).to.be("");
        
                              }
                    }
                    expect(data.spec.taskTemplate.placement.maxReplicas).to.be.a('number');
                    expect(data.spec.taskTemplate.placement.maxReplicas).to.be("0");
                    {
                      let dataCtr = data.spec.taskTemplate.placement.platforms;
                      expect(dataCtr).to.be.an(Array);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a(DockerEngineApi.Platform);
                        expect(data.architecture).to.be.a('string');
                        expect(data.architecture).to.be("x86_64");
                        expect(data.OS).to.be.a('string');
                        expect(data.OS).to.be("linux");
        
                              }
                    }
                  expect(data.spec.taskTemplate.forceUpdate).to.be.a('number');
                  expect(data.spec.taskTemplate.forceUpdate).to.be(0);
                  expect(data.spec.taskTemplate.runtime).to.be.a('string');
                  expect(data.spec.taskTemplate.runtime).to.be("");
                  {
                    let dataCtr = data.spec.taskTemplate.networks;
                    expect(dataCtr).to.be.an(Array);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a(DockerEngineApi.NetworkAttachmentConfig);
                      expect(data.target).to.be.a('string');
                      expect(data.target).to.be("");
                      {
                        let dataCtr = data.aliases;
                        expect(dataCtr).to.be.an(Array);
                        expect(dataCtr).to.not.be.empty();
                        for (let p in dataCtr) {
                          let data = dataCtr[p];
                          expect(data).to.be.a('string');
                          expect(data).to.be("");
                        }
                      }
                      {
                        let dataCtr = data.driverOpts;
                        expect(dataCtr).to.be.an(Object);
                        expect(dataCtr).to.not.be.empty();
                        for (let p in dataCtr) {
                          let data = dataCtr[p];
                          expect(data).to.be.a('string');
                          expect(data).to.be("");
                        }
                      }
      
                            }
                  }
                  expect(data.spec.taskTemplate.logDriver).to.be.a(DockerEngineApi.TaskSpecLogDriver);
                        expect(data.spec.taskTemplate.logDriver.name).to.be.a('string');
                    expect(data.spec.taskTemplate.logDriver.name).to.be("");
                    {
                      let dataCtr = data.spec.taskTemplate.logDriver.options;
                      expect(dataCtr).to.be.an(Object);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a('string');
                        expect(data).to.be("");
                      }
                    }
                expect(data.spec.mode).to.be.a(DockerEngineApi.ServiceSpecMode);
                      expect(data.spec.mode.replicated).to.be.a(DockerEngineApi.ServiceSpecModeReplicated);
                        expect(data.spec.mode.replicated.replicas).to.be.a('number');
                    expect(data.spec.mode.replicated.replicas).to.be("0");
                  expect(data.spec.mode.global).to.be.a(Object);
                  expect(data.spec.mode.global).to.be();
                  expect(data.spec.mode.replicatedJob).to.be.a(DockerEngineApi.ServiceSpecModeReplicatedJob);
                        expect(data.spec.mode.replicatedJob.maxConcurrent).to.be.a('number');
                    expect(data.spec.mode.replicatedJob.maxConcurrent).to.be("0");
                    expect(data.spec.mode.replicatedJob.totalCompletions).to.be.a('number');
                    expect(data.spec.mode.replicatedJob.totalCompletions).to.be("0");
                  expect(data.spec.mode.globalJob).to.be.a(Object);
                  expect(data.spec.mode.globalJob).to.be();
                expect(data.spec.updateConfig).to.be.a(DockerEngineApi.ServiceSpecUpdateConfig);
                      expect(data.spec.updateConfig.parallelism).to.be.a('number');
                  expect(data.spec.updateConfig.parallelism).to.be("0");
                  expect(data.spec.updateConfig.delay).to.be.a('number');
                  expect(data.spec.updateConfig.delay).to.be("0");
                  expect(data.spec.updateConfig.failureAction).to.be.a('string');
                  expect(data.spec.updateConfig.failureAction).to.be("continue");
                  expect(data.spec.updateConfig.monitor).to.be.a('number');
                  expect(data.spec.updateConfig.monitor).to.be("0");
                  expect(data.spec.updateConfig.maxFailureRatio).to.be.a('number');
                  expect(data.spec.updateConfig.maxFailureRatio).to.be();
                  expect(data.spec.updateConfig.order).to.be.a('string');
                  expect(data.spec.updateConfig.order).to.be("stop-first");
                expect(data.spec.rollbackConfig).to.be.a(DockerEngineApi.ServiceSpecRollbackConfig);
                      expect(data.spec.rollbackConfig.parallelism).to.be.a('number');
                  expect(data.spec.rollbackConfig.parallelism).to.be("0");
                  expect(data.spec.rollbackConfig.delay).to.be.a('number');
                  expect(data.spec.rollbackConfig.delay).to.be("0");
                  expect(data.spec.rollbackConfig.failureAction).to.be.a('string');
                  expect(data.spec.rollbackConfig.failureAction).to.be("continue");
                  expect(data.spec.rollbackConfig.monitor).to.be.a('number');
                  expect(data.spec.rollbackConfig.monitor).to.be("0");
                  expect(data.spec.rollbackConfig.maxFailureRatio).to.be.a('number');
                  expect(data.spec.rollbackConfig.maxFailureRatio).to.be();
                  expect(data.spec.rollbackConfig.order).to.be.a('string');
                  expect(data.spec.rollbackConfig.order).to.be("stop-first");
                {
                  let dataCtr = data.spec.networks;
                  expect(dataCtr).to.be.an(Array);
                  expect(dataCtr).to.not.be.empty();
                  for (let p in dataCtr) {
                    let data = dataCtr[p];
                    expect(data).to.be.a(DockerEngineApi.NetworkAttachmentConfig);
                    expect(data.target).to.be.a('string');
                    expect(data.target).to.be("");
                    {
                      let dataCtr = data.aliases;
                      expect(dataCtr).to.be.an(Array);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a('string');
                        expect(data).to.be("");
                      }
                    }
                    {
                      let dataCtr = data.driverOpts;
                      expect(dataCtr).to.be.an(Object);
                      expect(dataCtr).to.not.be.empty();
                      for (let p in dataCtr) {
                        let data = dataCtr[p];
                        expect(data).to.be.a('string');
                        expect(data).to.be("");
                      }
                    }
    
                          }
                }
                expect(data.spec.endpointSpec).to.be.a(DockerEngineApi.EndpointSpec);
                      expect(data.spec.endpointSpec.mode).to.be.a('string');
                  expect(data.spec.endpointSpec.mode).to.be("vip");
                  {
                    let dataCtr = data.spec.endpointSpec.ports;
                    expect(dataCtr).to.be.an(Array);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a(DockerEngineApi.EndpointPortConfig);
                      expect(data.name).to.be.a('string');
                      expect(data.name).to.be("");
                      expect(data.protocol).to.be.a('string');
                      expect(data.protocol).to.be("tcp");
                      expect(data.targetPort).to.be.a('number');
                      expect(data.targetPort).to.be(0);
                      expect(data.publishedPort).to.be.a('number');
                      expect(data.publishedPort).to.be(0);
                      expect(data.publishMode).to.be.a('string');
                      expect(data.publishMode).to.be("ingress");
      
                            }
                  }
              expect(data.endpoint).to.be.a(DockerEngineApi.ServiceEndpoint);
                    expect(data.endpoint.spec).to.be.a(DockerEngineApi.EndpointSpec);
                      expect(data.endpoint.spec.mode).to.be.a('string');
                  expect(data.endpoint.spec.mode).to.be("vip");
                  {
                    let dataCtr = data.endpoint.spec.ports;
                    expect(dataCtr).to.be.an(Array);
                    expect(dataCtr).to.not.be.empty();
                    for (let p in dataCtr) {
                      let data = dataCtr[p];
                      expect(data).to.be.a(DockerEngineApi.EndpointPortConfig);
                      expect(data.name).to.be.a('string');
                      expect(data.name).to.be("");
                      expect(data.protocol).to.be.a('string');
                      expect(data.protocol).to.be("tcp");
                      expect(data.targetPort).to.be.a('number');
                      expect(data.targetPort).to.be(0);
                      expect(data.publishedPort).to.be.a('number');
                      expect(data.publishedPort).to.be(0);
                      expect(data.publishMode).to.be.a('string');
                      expect(data.publishMode).to.be("ingress");
      
                            }
                  }
                {
                  let dataCtr = data.endpoint.ports;
                  expect(dataCtr).to.be.an(Array);
                  expect(dataCtr).to.not.be.empty();
                  for (let p in dataCtr) {
                    let data = dataCtr[p];
                    expect(data).to.be.a(DockerEngineApi.EndpointPortConfig);
                    expect(data.name).to.be.a('string');
                    expect(data.name).to.be("");
                    expect(data.protocol).to.be.a('string');
                    expect(data.protocol).to.be("tcp");
                    expect(data.targetPort).to.be.a('number');
                    expect(data.targetPort).to.be(0);
                    expect(data.publishedPort).to.be.a('number');
                    expect(data.publishedPort).to.be(0);
                    expect(data.publishMode).to.be.a('string');
                    expect(data.publishMode).to.be("ingress");
    
                          }
                }
                {
                  let dataCtr = data.endpoint.virtualIPs;
                  expect(dataCtr).to.be.an(Array);
                  expect(dataCtr).to.not.be.empty();
                  for (let p in dataCtr) {
                    let data = dataCtr[p];
                    expect(data).to.be.a(DockerEngineApi.ServiceEndpointVirtualIPs);
                    expect(data.networkID).to.be.a('string');
                    expect(data.networkID).to.be("");
                    expect(data.addr).to.be.a('string');
                    expect(data.addr).to.be("");
    
                          }
                }
              expect(data.updateStatus).to.be.a(DockerEngineApi.ServiceUpdateStatus);
                    expect(data.updateStatus.state).to.be.a('string');
                expect(data.updateStatus.state).to.be("updating");
                expect(data.updateStatus.startedAt).to.be.a('string');
                expect(data.updateStatus.startedAt).to.be("");
                expect(data.updateStatus.completedAt).to.be.a('string');
                expect(data.updateStatus.completedAt).to.be("");
                expect(data.updateStatus.message).to.be.a('string');
                expect(data.updateStatus.message).to.be("");
              expect(data.serviceStatus).to.be.a(DockerEngineApi.ServiceServiceStatus);
                    expect(data.serviceStatus.runningTasks).to.be.a('number');
                expect(data.serviceStatus.runningTasks).to.be(7);
                expect(data.serviceStatus.desiredTasks).to.be.a('number');
                expect(data.serviceStatus.desiredTasks).to.be(10);
                expect(data.serviceStatus.completedTasks).to.be.a('number');
                expect(data.serviceStatus.completedTasks).to.be(0);
              expect(data.jobStatus).to.be.a(DockerEngineApi.ServiceJobStatus);
                    expect(data.jobStatus.jobIteration).to.be.a(DockerEngineApi.ObjectVersion);
                      expect(data.jobStatus.jobIteration.index).to.be.a('number');
                  expect(data.jobStatus.jobIteration.index).to.be(373531);
                expect(data.jobStatus.lastExecution).to.be.a('string');
                expect(data.jobStatus.lastExecution).to.be("");
            }

            done();
          });
          */
          // TODO: uncomment and complete method invocation above, then delete this line and the next:
          done();
        });
      });
      describe('serviceLogs', function() {
        it('should call serviceLogs successfully', function(done) {
          // TODO: uncomment, update parameter values for serviceLogs call and complete the assertions
          /*
          var id = "id_example";
          var opts = {};
          opts.details = false;
          opts.follow = false;
          opts.stdout = false;
          opts.stderr = false;
          opts.since = 0;
          opts.timestamps = false;
          opts.tail = "all";

          instance.serviceLogs(id, opts, function(error, data, response) {
            if (error) {
              done(error);
              return;
            }
            // TODO: update response assertions
            expect(data).to.be.a(Blob);
            // expect(data).to.be(null);

            done();
          });
          */
          // TODO: uncomment and complete method invocation above, then delete this line and the next:
          done();
        });
      });
      describe('serviceUpdate', function() {
        it('should call serviceUpdate successfully', function(done) {
          // TODO: uncomment, update parameter values for serviceUpdate call and complete the assertions
          /*
          var id = "id_example";
          var body = new DockerEngineApi.object();
          var version = 56;
          var opts = {};
          opts.registryAuthFrom = "spec";
          opts.rollback = "rollback_example";
          opts.xRegistryAuth = "xRegistryAuth_example";

          instance.serviceUpdate(id, body, version, opts, function(error, data, response) {
            if (error) {
              done(error);
              return;
            }
            // TODO: update response assertions
            expect(data).to.be.a(DockerEngineApi.ServiceUpdateResponse);
            {
              let dataCtr = data.warnings;
              expect(dataCtr).to.be.an(Array);
              expect(dataCtr).to.not.be.empty();
              for (let p in dataCtr) {
                let data = dataCtr[p];
                expect(data).to.be.a('string');
                expect(data).to.be("");
              }
            }

            done();
          });
          */
          // TODO: uncomment and complete method invocation above, then delete this line and the next:
          done();
        });
      });
    });
  });

}));
